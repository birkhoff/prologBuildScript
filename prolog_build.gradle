apply plugin: 'base'
import groovy.io.FileType

try{
		enable_tests = true
}	catch(MissingPropertyException e){
		project.ext.enable_tests = false
}

try{
	c_srcs = c_srcs
}catch(MissingPropertyException e){
	project.ext.c_srcs = "${projectDir}/src/cpp/"
}

try{
	pl_srcs = pl_srcs
}catch(MissingPropertyException e){
	project.ext.pl_srcs = "${projectDir}/src/prolog/"
}

try{
	outputName = outputName
}catch(MissingPropertyException e){
	project.ext.outputName = project.name
}


// specify where libraries are located
try{
	project.ext.libFolder = new File( lib )
}catch(MissingPropertyException e ){
	project.ext.libFolder = new File( "${projectDir}/src/cpp/lib" )
}


// name the goal for splfr
try{
	goal = goal
} catch(MissingPropertyException e) {
	project.ext.goal = "at_build"
}

// set c Flags for Compiler
try{
	c_flags = c_flags
} catch(MissingPropertyException e) {
	project.ext.c_flags = [ '--cflag=-m64', '-lgcc', '-lstdc++']
}


// defines prolog tests predicates which are triggered
try{
	pl_tests = pl_tests
}catch(MissingPropertyException e){
	project.ext.pl_tests = "test,halt."
}

project.ext {
	
	OS = System.getProperty("os.name"); 
	OSArch = System.getProperty("os.arch")
	
	isMac = false
	isWindows = false
	isLinux = false
	shext = "bundle"
	
	if (OS.startsWith("Mac")) {
	
		isMac = true
		shext = "bundle"
	} else	if ( OS.startsWith("Windows")) {
	
		isWindows = true
		shext = "dll"
	} else {
	
	 	isLinux = true
		shext = "so"
	}
	
	OSBit = 32
	if (OSArch.contains("64")) {
		
		OSBit = 64
	}
	
	println "currently runnning on: " + OS + " " + OSBit +" Bit" +"\n"
	
	getLibraries()
}


// Collecting Libaries by default from the folder src/cpp/lib
// In this folder it is checked if there are sub folders which names contain 32 or 64
// So the script can automatically attach the libraries according to your system

void getLibraries() {
	
	project.ext.libraries = []				// List collecting all libs
	
	if(libFolder.exists()){
		
		architectures = libFolder.listFiles()
		libFolder.eachDir(){
			
			if (it.name ==~ /.*32.*/ && OSBit == 32) {
				
				String bitFolder = it.name
				it.eachFile FileType.FILES, {
				
					if (it.name ==~ /.*\.so(\.[0-9]*)*/ && isLinux)		libraries << libFolder.name + bitFolder + it.name	
					if (it.name ==~ /.*\.a/ && isMac) 					libraries << libFolder.name + bitFolder + it.name
					if (it.name ==~ /.*\.dll/ && isWindows)				libraries << libFolder.name + bitFolder + it.name
				}
			}else if (it.name ==~ /.*64.*/ && OSBit == 64) {
				
				String bitFolder = it.name
				it.eachFile FileType.FILES, {
					
					if (it.name ==~ /.*\.so(\.[0-9]*)*/ && isLinux)		libraries << "${libFolder}/${bitFolder}/${it.name}"
					if (it.name ==~ /.*\.a/ && isMac) 					libraries << "${libFolder}/${bitFolder}/${it.name}"
					if (it.name ==~ /.*\.dll/ && isWindows)				libraries << "${libFolder}/${bitFolder}/${it.name}"	
				}
			}
		}
		libFolder.eachFile FileType.FILES, {
		
			if (it.name ==~ /.*\.so(\.[0-9]*)*/ && isLinux)				libraries << libFolder.name + it.name
			if (it.name ==~ /.*\.a/ && isMac) 							libraries << libFolder.name + it.name
			if (it.name ==~ /.*\.dll/ && isWindows)						libraries << libFolder.name + it.name		
		}
	}
}

try{
	outputfile = outputfile
}catch(MissingPropertyException e){
	project.ext.outputfile = project.name + shext
}


try{
	pl_file = pl_file
}catch(MissingPropertyException e){
	
	// prolog files
	def prologFolder = new File (pl_srcs)
	def pl_src_files = prologFolder.listFiles()
	
	project.ext.pl_files = []
	
	if(pl_src_files != null){
		int k = 0
		for( int i = 0; i < pl_src_files.size(); i++){
			if( pl_src_files[i].getName() ==~ /.*\.pl/ && !(pl_src_files[i].getName() ==~ /.*[tT]est.*/) ){
				pl_files[k] = pl_src_files[i].getName() 
				k++
			}
		}
	}
	if(pl_files.size()>1){ 
		
		System.out.println "\n\tSwagOverflow Error!"
		throw new IllegalArgumentException("Number of Prolog Sources must be exactly one. \nPlease define the Prolog Sources in another subfolder like /resources");
	}
	project.ext.pl_file = pl_files[0]
	println "Currently linking " + pl_file
}

try{	
	pl_ressource = pl_ressource
}catch(MissingPropertyException e){
	project.ext.pl_ressource = pl_file.replaceAll(".pl", '')
}

try{
	
	pl_test_file = pl_test_file
}catch(MissingPropertyException e){
	project.ext.pl_test_file = pl_file
}


try{	
	pl_test_module = pl_test_module
}catch(MissingPropertyException e){
	project.ext.pl_test_module = pl_file.replaceAll(".pl", '')
}

// c files for the linker for this library only

try{
	c_files = c_files
}catch(MissingPropertyException e){
	
	// c files
	def c_src_folder = new File (c_srcs)
	def c_src_files = c_src_folder.listFiles()
	
	 project.ext.c_files = []
		
	if(c_src_files != null){
		int k = 0
		for( int i = 0; i < c_src_files.size(); i++){
			if( c_src_files[i].getName() ==~ /.*\.cpp/ || c_src_files[i].getName() ==~ /.*\.c/ ){
				c_files[k] = c_srcs+c_src_files[i].getName() 
				k++
			}
		}
	}
	
	//println "\nc files to compile: " + c_files + "\n"
}


// c files which are referenced in a ressources folder which will be used by multiple libraries 
// the file can be defined with c_resource_dir = "your_folder/"

try{
	
	c_resource_dir = c_resource_dir
	
}catch(MissingPropertyException e){
	
	c_resource_dir = null
	println "no external resources defined"
}


// c files for the linker for this library only

try{
	c_resources = c_resources
}catch(MissingPropertyException e){
	
	// c files	
	project.ext.c_resources = []
	
	if (c_resource_dir != null) {
		def c_rsrc_folder = new File (c_resource_dir)
		def c_rsrc_files = c_rsrc_folder.listFiles()
			
		if(c_rsrc_files != null){
			int k = 0
			for( int i = 0; i < c_rsrc_files.size(); i++){
				if( c_rsrc_files[i].getName() ==~ /.*\.cpp/ || c_rsrc_files[i].getName() ==~ /.*\.c/ ){
					c_resources[k] = c_resource_dir+c_rsrc_files[i].getName() 
					k++
				}
			}
		}
	
	}
}


try{
	
	outputFiles = outputFiles
	destDir = new File( outputFiles)
}catch(MissingPropertyException e){
	project.ext.outputFiles	= "${buildDir}/lib/"
	destDir = new File( outputFiles)
}


try{
	extensionBuildFiles = extensionBuildFiles
	extensionBuildDir = new File ( extensionBuildFiles)
	
}catch(MissingPropertyException e){
	project.ext.extensionBuildFiles = "${buildDir}/"
	extensionBuildDir = new File ( extensionBuildFiles)
	
}


try{
	
	sicstusDir = sicstusDir
}catch(MissingPropertyException e){
	project.ext.sicstusDir = "/usr/local/sicstus/"
	
}


task "link_$project.name" ( dependsOn: ['makeLibDir'], type:Exec) {
	
	inputs.dir pl_srcs
	inputs.dir c_srcs
	
	if (c_resource_dir != null) 	inputs.dir c_resource_dir
    if (libFolder.exists()) 			inputs.dir libFolder
	outputs.file outputFiles+ outputName +"."+shext
    //outputs.file outputName+"."+shext	

	all_c_files = c_files
	if (c_resource_dir != null) all_c_files = all_c_files + c_resources
	if (libraries != null && libraries.size != 0) all_c_files = all_c_files + ["-lstdc++"]+libraries + ["--LD"]
	//println "Libaries: " + libraries	

	commandLine  = ['splfr', '--verbose', '--output='+ outputFiles + outputName +'.'+shext, '--resource='+pl_ressource, "--source=" + pl_srcs +pl_file] + c_flags + all_c_files
}


task makeLibDir() << {

	extensionBuildDir.mkdir()
	destDir.mkdir()
}

task "plTest_$project.name" ( dependsOn: ['makeLibDir'], type:Exec) {
	if (enable_tests) {
	commandLine  'sicstus', '-l', pl_srcs+pl_test_file, '--goal', "${pl_test_module}:assert(user:library_directory('${outputFiles}')),${pl_tests}" 
	// sicstus -l myheap.pl --goal "myheap:test,halt."
	}else{
		println "\n\tTests not enabled for project: ${projectDir}\n"
	}
}









